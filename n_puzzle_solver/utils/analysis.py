"""
M√≥dulo de An√°lise Comparativa e Relat√≥rios
Implementa todas as funcionalidades de an√°lise solicitadas na especifica√ß√£o
"""

import time
import json
from typing import Dict, List, Any, Tuple, Optional
from dataclasses import dataclass, asdict
from datetime import datetime
import os
import sys

try:
    import matplotlib.pyplot as plt
    import pandas as pd
    import seaborn as sns
    HAS_PLOTTING = True
except ImportError:
    HAS_PLOTTING = False


@dataclass
class AlgorithmResult:
    """Resultado detalhado de execu√ß√£o de um algoritmo."""
    name: str
    success: bool
    execution_time: float
    nodes_explored: int
    solution_length: int
    max_depth: int
    memory_usage: int
    heuristic: Optional[str] = None
    optimal: bool = True
    solution_path: List[str] = None
    search_tree_info: Dict[str, Any] = None


@dataclass
class ProblemInstance:
    """Inst√¢ncia de problema para an√°lise."""
    name: str
    size: int
    initial_state: List[List[int]]
    difficulty: str
    description: str


class ComparisonAnalyzer:
    """Analisador comparativo de algoritmos de busca."""
    
    def __init__(self):
        """Inicializa o analisador."""
        self.results: Dict[str, List[AlgorithmResult]] = {}
        self.problems: List[ProblemInstance] = []
        
    def add_result(self, problem_name: str, result: AlgorithmResult):
        """Adiciona resultado de execu√ß√£o."""
        if problem_name not in self.results:
            self.results[problem_name] = []
        self.results[problem_name].append(result)
    
    def add_problem(self, problem: ProblemInstance):
        """Adiciona inst√¢ncia de problema."""
        self.problems.append(problem)
    
    def generate_comparison_table(self) -> str:
        """Gera tabela comparativa dos resultados."""
        if not self.results:
            return "‚ùå Nenhum resultado para comparar."
        
        table = "üìä TABELA COMPARATIVA DE ALGORITMOS\n"
        table += "=" * 80 + "\n"
        
        # Cabe√ßalho
        table += f"{'Problema':<15} {'Algoritmo':<12} {'Sucesso':<8} {'Tempo(s)':<10} "
        table += f"{'N√≥s':<8} {'Passos':<8} {'Prof.':<8} {'Mem.(KB)':<10}\n"
        table += "-" * 80 + "\n"
        
        for problem_name, results in self.results.items():
            for i, result in enumerate(results):
                prob_name = problem_name if i == 0 else ""
                success_str = "‚úÖ" if result.success else "‚ùå"
                
                table += f"{prob_name:<15} {result.name:<12} {success_str:<8} "
                table += f"{result.execution_time:<10.3f} {result.nodes_explored:<8} "
                table += f"{result.solution_length:<8} {result.max_depth:<8} "
                table += f"{result.memory_usage:<10}\n"
            
            if len(results) > 1:
                table += "-" * 80 + "\n"
        
        return table
    
    def generate_performance_summary(self) -> str:
        """Gera resumo de performance dos algoritmos."""
        if not self.results:
            return "‚ùå Nenhum resultado para analisar."
        
        summary = "\nüìà RESUMO DE PERFORMANCE\n"
        summary += "=" * 50 + "\n"
        
        # Coleta estat√≠sticas por algoritmo
        algo_stats = {}
        for results in self.results.values():
            for result in results:
                if result.name not in algo_stats:
                    algo_stats[result.name] = {
                        'executions': 0,
                        'successes': 0,
                        'total_time': 0,
                        'total_nodes': 0,
                        'total_steps': 0,
                        'times': [],
                        'nodes': [],
                        'steps': []
                    }
                
                stats = algo_stats[result.name]
                stats['executions'] += 1
                if result.success:
                    stats['successes'] += 1
                    stats['total_time'] += result.execution_time
                    stats['total_nodes'] += result.nodes_explored
                    stats['total_steps'] += result.solution_length
                    stats['times'].append(result.execution_time)
                    stats['nodes'].append(result.nodes_explored)
                    stats['steps'].append(result.solution_length)
        
        # Gera estat√≠sticas
        for algo_name, stats in algo_stats.items():
            summary += f"\nüîç {algo_name}:\n"
            summary += f"  Execu√ß√µes: {stats['executions']}\n"
            summary += f"  Taxa de Sucesso: {stats['successes']}/{stats['executions']}"
            summary += f" ({100*stats['successes']/stats['executions']:.1f}%)\n"
            
            if stats['successes'] > 0:
                avg_time = stats['total_time'] / stats['successes']
                avg_nodes = stats['total_nodes'] / stats['successes'] 
                avg_steps = stats['total_steps'] / stats['successes']
                
                summary += f"  Tempo M√©dio: {avg_time:.3f}s\n"
                summary += f"  N√≥s M√©dios: {avg_nodes:.1f}\n"
                summary += f"  Passos M√©dios: {avg_steps:.1f}\n"
                
                if len(stats['times']) > 1:
                    min_time = min(stats['times'])
                    max_time = max(stats['times'])
                    summary += f"  Tempo Min/Max: {min_time:.3f}s / {max_time:.3f}s\n"
        
        return summary
    
    def generate_algorithm_ranking(self) -> str:
        """Gera ranking dos algoritmos por diferentes crit√©rios."""
        if not self.results:
            return "‚ùå Nenhum resultado para ranking."
        
        ranking = "\nüèÜ RANKING DE ALGORITMOS\n"
        ranking += "=" * 40 + "\n"
        
        # Coleta dados para ranking
        algo_performance = {}
        for results in self.results.values():
            for result in results:
                if result.success:
                    if result.name not in algo_performance:
                        algo_performance[result.name] = {
                            'times': [],
                            'nodes': [],
                            'optimal_count': 0,
                            'total_count': 0
                        }
                    
                    perf = algo_performance[result.name]
                    perf['times'].append(result.execution_time)
                    perf['nodes'].append(result.nodes_explored)
                    if result.optimal:
                        perf['optimal_count'] += 1
                    perf['total_count'] += 1
        
        # Ranking por velocidade (tempo m√©dio)
        if algo_performance:
            ranking += "\n‚ö° Por Velocidade (Tempo M√©dio):\n"
            speed_ranking = sorted(algo_performance.items(), 
                                 key=lambda x: sum(x[1]['times'])/len(x[1]['times']))
            for i, (name, perf) in enumerate(speed_ranking, 1):
                avg_time = sum(perf['times']) / len(perf['times'])
                ranking += f"  {i}. {name}: {avg_time:.3f}s\n"
            
            # Ranking por efici√™ncia (n√≥s explorados)
            ranking += "\nüéØ Por Efici√™ncia (N√≥s M√©dios):\n"
            efficiency_ranking = sorted(algo_performance.items(),
                                      key=lambda x: sum(x[1]['nodes'])/len(x[1]['nodes']))
            for i, (name, perf) in enumerate(efficiency_ranking, 1):
                avg_nodes = sum(perf['nodes']) / len(perf['nodes'])
                ranking += f"  {i}. {name}: {avg_nodes:.1f} n√≥s\n"
            
            # Ranking por otimalidade
            ranking += "\n‚ú® Por Otimalidade:\n"
            optimal_ranking = sorted(algo_performance.items(),
                                   key=lambda x: x[1]['optimal_count']/x[1]['total_count'],
                                   reverse=True)
            for i, (name, perf) in enumerate(optimal_ranking, 1):
                optimal_rate = perf['optimal_count'] / perf['total_count']
                ranking += f"  {i}. {name}: {optimal_rate:.1%} solu√ß√µes √≥timas\n"
        
        return ranking
    
    def generate_detailed_report(self) -> str:
        """Gera relat√≥rio completo de an√°lise."""
        report = "üìã RELAT√ìRIO COMPLETO DE AN√ÅLISE N-PUZZLE\n"
        report += "=" * 60 + "\n"
        report += f"Data: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\n"
        report += f"Problemas Analisados: {len(self.problems)}\n"
        report += f"Execu√ß√µes Realizadas: {sum(len(results) for results in self.results.values())}\n"
        report += "\n"
        
        # Se√ß√£o 1: Formula√ß√£o do Problema
        report += "üîç 1. FORMULA√á√ÉO DO PROBLEMA\n"
        report += "-" * 30 + "\n"
        report += "‚Ä¢ Representa√ß√£o dos estados: Matriz NxN com n√∫meros 1 a N¬≤-1 e 0 (espa√ßo vazio)\n"
        report += "‚Ä¢ Estado inicial: Configura√ß√£o fornecida pelo usu√°rio\n"
        report += "‚Ä¢ Estado objetivo: N√∫meros ordenados sequencialmente com 0 no final\n"
        report += "‚Ä¢ Operadores: Mover espa√ßo vazio para cima, baixo, esquerda, direita\n"
        report += "‚Ä¢ Condi√ß√£o objetivo: Estado atual == estado objetivo\n"
        report += "‚Ä¢ Custo de a√ß√£o: Uniforme = 1 para todos os movimentos\n\n"
        
        # Se√ß√£o 2: Problemas Testados
        report += "üß© 2. INST√ÇNCIAS DE PROBLEMAS TESTADAS\n"
        report += "-" * 35 + "\n"
        for problem in self.problems:
            report += f"‚Ä¢ {problem.name}: {problem.size}x{problem.size} - {problem.difficulty}\n"
            report += f"  Descri√ß√£o: {problem.description}\n"
        report += "\n"
        
        # Se√ß√£o 3: Tabela Comparativa
        report += "üìä 3. RESULTADOS COMPARATIVOS\n"
        report += "-" * 30 + "\n"
        report += self.generate_comparison_table()
        report += "\n"
        
        # Se√ß√£o 4: An√°lise de Performance
        report += "üìà 4. AN√ÅLISE DE PERFORMANCE\n"
        report += "-" * 28 + "\n"
        report += self.generate_performance_summary()
        report += "\n"
        
        # Se√ß√£o 5: Rankings
        report += "üèÜ 5. RANKINGS COMPARATIVOS\n"
        report += "-" * 27 + "\n"
        report += self.generate_algorithm_ranking()
        report += "\n"
        
        # Se√ß√£o 6: Conclus√µes
        report += "üí° 6. CONCLUS√ïES E RECOMENDA√á√ïES\n"
        report += "-" * 33 + "\n"
        report += self._generate_conclusions()
        
        return report
    
    def _generate_conclusions(self) -> str:
        """Gera conclus√µes baseadas nos resultados."""
        if not self.results:
            return "‚ùå Dados insuficientes para conclus√µes."
        
        conclusions = ""
        
        # An√°lise de algoritmos sem informa√ß√£o
        uninformed_algos = ['BFS', 'DFS', 'IDS']
        informed_algos = ['A*', 'Greedy']
        
        has_uninformed = any(any(r.name in uninformed_algos for r in results) 
                           for results in self.results.values())
        has_informed = any(any(r.name in informed_algos for r in results)
                         for results in self.results.values())
        
        if has_uninformed:
            conclusions += "üîç BUSCAS SEM INFORMA√á√ÉO:\n"
            conclusions += "‚Ä¢ BFS: Garante solu√ß√£o √≥tima, mas uso intensivo de mem√≥ria\n"
            conclusions += "‚Ä¢ DFS: Menor uso de mem√≥ria, mas n√£o garante otimalidade\n"
            conclusions += "‚Ä¢ IDS: Combina vantagens de BFS e DFS\n\n"
        
        if has_informed:
            conclusions += "‚≠ê BUSCAS COM INFORMA√á√ÉO:\n"
            conclusions += "‚Ä¢ A*: Melhor para solu√ß√µes √≥timas com heur√≠sticas admiss√≠veis\n"
            conclusions += "‚Ä¢ Greedy: Mais r√°pida, mas n√£o garante otimalidade\n"
            conclusions += "‚Ä¢ Heur√≠stica Manhattan geralmente superior a Misplaced Tiles\n\n"
        
        conclusions += "üìã RECOMENDA√á√ïES DE USO:\n"
        conclusions += "‚Ä¢ Para puzzles 8: Todos os algoritmos funcionam bem\n"
        conclusions += "‚Ä¢ Para puzzles 15: Prefira algoritmos informados (A*, Greedy)\n"
        conclusions += "‚Ä¢ Para puzzles 24: Use apenas A* com heur√≠sticas eficientes\n"
        conclusions += "‚Ä¢ Para an√°lise educacional: Compare BFS vs DFS vs A*\n"
        
        return conclusions
    
    def save_report(self, filename: str = None) -> str:
        """Salva relat√≥rio em arquivo."""
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"relatorio_npuzzle_{timestamp}.txt"
        
        try:
            report = self.generate_detailed_report()
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(report)
            return f"‚úÖ Relat√≥rio salvo em: {filename}"
        except Exception as e:
            return f"‚ùå Erro ao salvar relat√≥rio: {e}"
    
    def export_data_json(self, filename: str = None) -> str:
        """Exporta dados em formato JSON."""
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"dados_npuzzle_{timestamp}.json"
        
        try:
            data = {
                'metadata': {
                    'export_date': datetime.now().isoformat(),
                    'total_problems': len(self.problems),
                    'total_executions': sum(len(results) for results in self.results.values())
                },
                'problems': [asdict(p) for p in self.problems],
                'results': {
                    problem: [asdict(result) for result in results]
                    for problem, results in self.results.items()
                }
            }
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            
            return f"‚úÖ Dados exportados em: {filename}"
        except Exception as e:
            return f"‚ùå Erro ao exportar dados: {e}"
    
    def create_performance_plots(self, output_dir: str = "graficos") -> str:
        """Cria gr√°ficos de performance (requer matplotlib)."""
        if not HAS_PLOTTING:
            return ("‚ùå Bibliotecas de gr√°ficos n√£o instaladas.\n"
                   "Execute: pip install matplotlib pandas seaborn")
        
        if not self.results:
            return "‚ùå Nenhum resultado para plotar."
        
        try:
            os.makedirs(output_dir, exist_ok=True)
            
            # Prepara dados
            data = []
            for problem_name, results in self.results.items():
                for result in results:
                    if result.success:
                        data.append({
                            'Problema': problem_name,
                            'Algoritmo': result.name,
                            'Tempo (s)': result.execution_time,
                            'N√≥s Explorados': result.nodes_explored,
                            'Passos Solu√ß√£o': result.solution_length,
                            'Heur√≠stica': result.heuristic or 'N/A'
                        })
            
            if not data:
                return "‚ùå Nenhum resultado bem-sucedido para plotar."
            
            df = pd.DataFrame(data)
            
            # Configura√ß√£o de estilo
            plt.style.use('seaborn-v0_8' if 'seaborn-v0_8' in plt.style.available else 'default')
            
            # Gr√°fico 1: Tempo de Execu√ß√£o
            plt.figure(figsize=(12, 8))
            if len(df['Problema'].unique()) > 1:
                sns.barplot(data=df, x='Algoritmo', y='Tempo (s)', hue='Problema')
                plt.title('Compara√ß√£o de Tempo de Execu√ß√£o por Algoritmo e Problema')
            else:
                sns.barplot(data=df, x='Algoritmo', y='Tempo (s)')
                plt.title('Compara√ß√£o de Tempo de Execu√ß√£o por Algoritmo')
            plt.xticks(rotation=45)
            plt.tight_layout()
            plt.savefig(f"{output_dir}/tempo_execucao.png", dpi=300, bbox_inches='tight')
            plt.close()
            
            # Gr√°fico 2: N√≥s Explorados
            plt.figure(figsize=(12, 8))
            if len(df['Problema'].unique()) > 1:
                sns.barplot(data=df, x='Algoritmo', y='N√≥s Explorados', hue='Problema')
                plt.title('Compara√ß√£o de N√≥s Explorados por Algoritmo e Problema')
            else:
                sns.barplot(data=df, x='Algoritmo', y='N√≥s Explorados')
                plt.title('Compara√ß√£o de N√≥s Explorados por Algoritmo')
            plt.xticks(rotation=45)
            plt.tight_layout()
            plt.savefig(f"{output_dir}/nos_explorados.png", dpi=300, bbox_inches='tight')
            plt.close()
            
            # Gr√°fico 3: Efici√™ncia (Tempo vs N√≥s)
            plt.figure(figsize=(10, 8))
            for algo in df['Algoritmo'].unique():
                algo_data = df[df['Algoritmo'] == algo]
                plt.scatter(algo_data['N√≥s Explorados'], algo_data['Tempo (s)'], 
                           label=algo, alpha=0.7, s=60)
            
            plt.xlabel('N√≥s Explorados')
            plt.ylabel('Tempo de Execu√ß√£o (s)')
            plt.title('Efici√™ncia dos Algoritmos (Tempo vs N√≥s Explorados)')
            plt.legend()
            plt.grid(True, alpha=0.3)
            plt.tight_layout()
            plt.savefig(f"{output_dir}/eficiencia.png", dpi=300, bbox_inches='tight')
            plt.close()
            
            # Gr√°fico 4: Distribui√ß√£o de Performance
            if len(df) > 10:  # S√≥ faz sentido com muitos dados
                fig, axes = plt.subplots(1, 2, figsize=(15, 6))
                
                # Distribui√ß√£o de tempos
                sns.boxplot(data=df, x='Algoritmo', y='Tempo (s)', ax=axes[0])
                axes[0].set_title('Distribui√ß√£o dos Tempos de Execu√ß√£o')
                axes[0].tick_params(axis='x', rotation=45)
                
                # Distribui√ß√£o de n√≥s
                sns.boxplot(data=df, x='Algoritmo', y='N√≥s Explorados', ax=axes[1])
                axes[1].set_title('Distribui√ß√£o dos N√≥s Explorados')
                axes[1].tick_params(axis='x', rotation=45)
                
                plt.tight_layout()
                plt.savefig(f"{output_dir}/distribuicao.png", dpi=300, bbox_inches='tight')
                plt.close()
            
            return f"‚úÖ Gr√°ficos salvos no diret√≥rio: {output_dir}/"
            
        except Exception as e:
            return f"‚ùå Erro ao criar gr√°ficos: {e}"


class SearchTreeVisualizer:
    """Visualizador de √°rvores de busca."""
    
    def __init__(self):
        """Inicializa o visualizador."""
        self.tree_data = {}
    
    def generate_tree_representation(self, puzzle, solution_path: List[str]) -> str:
        """Gera representa√ß√£o textual da √°rvore de busca."""
        tree_str = "üå≥ √ÅRVORE DE BUSCA (Caminho da Solu√ß√£o)\n"
        tree_str += "=" * 50 + "\n"
        
        if not solution_path:
            tree_str += "üìç Estado Inicial (j√° √© objetivo)\n"
            tree_str += puzzle.visualize()
            return tree_str
        
        tree_str += "üìç Estado Inicial:\n"
        tree_str += puzzle.visualize() + "\n"
        
        current_puzzle = puzzle.copy()
        for i, move in enumerate(solution_path):
            tree_str += f"    |\n    üìÅ Movimento {i+1}: {move}\n    |\n    v\n"
            
            # Aplica movimento
            if move == "UP":
                current_puzzle.move_up()
            elif move == "DOWN":
                current_puzzle.move_down()
            elif move == "LEFT":
                current_puzzle.move_left()
            elif move == "RIGHT":
                current_puzzle.move_right()
            
            # Mostra estado resultante
            tree_str += current_puzzle.visualize()
            
            if i < len(solution_path) - 1:
                tree_str += "\n"
        
        tree_str += "\nüéØ Estado Objetivo Alcan√ßado!\n"
        
        return tree_str
    
    def generate_path_analysis(self, puzzle, solution_path: List[str]) -> str:
        """Gera an√°lise detalhada do caminho da solu√ß√£o."""
        if not solution_path:
            return "üéØ Solu√ß√£o encontrada no estado inicial (0 movimentos)."
        
        analysis = "üìä AN√ÅLISE DO CAMINHO DA SOLU√á√ÉO\n"
        analysis += "=" * 40 + "\n"
        analysis += f"üìè Comprimento do caminho: {len(solution_path)} movimentos\n"
        analysis += f"üéØ Sequ√™ncia de movimentos: {' ‚Üí '.join(solution_path)}\n\n"
        
        # An√°lise de padr√µes de movimento
        move_counts = {}
        for move in solution_path:
            move_counts[move] = move_counts.get(move, 0) + 1
        
        analysis += "üìà Distribui√ß√£o de movimentos:\n"
        for move, count in sorted(move_counts.items()):
            percentage = (count / len(solution_path)) * 100
            analysis += f"  {move}: {count} vezes ({percentage:.1f}%)\n"
        
        # Verifica efici√™ncia
        total_moves = len(solution_path)
        if total_moves <= 10:
            efficiency = "Muito Eficiente"
        elif total_moves <= 20:
            efficiency = "Eficiente"
        elif total_moves <= 30:
            efficiency = "Moderado"
        else:
            efficiency = "Pode ser otimizado"
        
        analysis += f"\nüí° Avalia√ß√£o de efici√™ncia: {efficiency}\n"
        
        return analysis


# Fun√ß√µes utilit√°rias para integra√ß√£o com o sistema principal
def create_comparison_analyzer() -> ComparisonAnalyzer:
    """Cria e retorna uma inst√¢ncia do analisador comparativo."""
    return ComparisonAnalyzer()


def create_tree_visualizer() -> SearchTreeVisualizer:
    """Cria e retorna uma inst√¢ncia do visualizador de √°rvores."""
    return SearchTreeVisualizer()
